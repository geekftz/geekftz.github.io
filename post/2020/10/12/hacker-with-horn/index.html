<!doctype html><html lang=en-us><head><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=manifest href=/images/site.webmanifest><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A simple, minimal blog for those who love text."><title>Plan 2020,Oct | hackftz</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://hackftz.github.io/css/theme-override.css><header><nav><ul><li class=pull-left><a href=https://hackftz.github.io/>~/hackftz</a></li><li class=pull-left><a href=/categories/>~/categories</a></li><li class=pull-left><a href=/tags/>~/tags</a></li><li class=pull-right><a href=https://github.com/hackftz>~/github</a></li></ul></nav></header></head><body><br><div class=article-meta><h1><span class=title>Plan 2020,Oct</span></h1><h2 class=author>Open-Source</h2><h2 class=date>2020/10/12</h2><p class=terms>Categories: <a href=/categories/plan>Plan</a>
Tags: <a href=/tags/2020-10>2020-10</a></p></div><div class=content-wrapper><main><ol><li>深入理解ts语法、用法、源码分析（暂时不用）</li><li>深入理解react 近版本迭代区别以及为何、语法、用法、源码分析</li><li>每天阅读至少三篇技术博客 阅读完在这里进行打卡record</li></ol><hr><h3 id=打卡>打卡</h3><ul><li><p>2020-10-26</p><ol><li><a href=https://www.jianshu.com/p/b71e56ea2fda>useMemo和useCallback的使用</a><br>useMemo：<br>官方解释：把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。<br>个人定义：useMemo是为了减少不必要的重复计算。如果依赖无变化，会使用缓存的值；依赖变化的话，计算执行，并替换缓存值。<br>useCallback：<br>官方定义：把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。<br>个人定义：当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。也就是说父组件传递一个函数给子组件的时候，由于父组件的更新会导致该函数重新生成从而传递给子组件的函数引用发生了变化，这就会导致子组件也会更新，而很多时候子组件的更新是没必要的，所以我们可以通过useCallback来缓存该函数，然后传递给子组件。</li><li><a href=https://www.cnblogs.com/yydcdut/p/3736667.html>上传文件multipart form-data boundary 说明</a></li><li>formdata实现原理（后续梳理，已发博客）</li></ol></li><li><p>2020-10-25</p><ol><li><a href=https://blog.csdn.net/wu_xianqiang/article/details/105181044>useState用法指南</a><br>hooks中useState返回setXXX的用法，一种参数是直接赋值，一种是参数是匿名函数，两种之间的区别是：同步过程下没有区别，异步情况下，由于匿名函数中可以获取到prevXXX，所以可以获取到上一次状态，因此会在倒计时完成时触发一次次更新。<br>异步条件下，与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。</li></ol></li><li><p>2020-10-24</p><ol><li><a href=https://blog.csdn.net/wu_xianqiang/article/details/105181044>useState用法指南</a><br>hooks中useState返回setXXX的用法，一种参数是直接赋值，一种是参数是匿名函数，两种之间的区别是：同步过程下没有区别，异步情况下，由于匿名函数中可以获取到prevXXX，所以可以获取到上一次状态，因此会在倒计时完成时触发一次次更新。</li><li>formdata实现原理（前言）</li></ol></li><li><p>2020-10-21</p><ol><li>React 16 要更改组件的生命周期<br>废弃了 componentWillMount，新增了 getDerivedStateFromProps。<br>消失的 componentWillMount 与新增的 getSnapshotBeforeUpdate。</li><li>React 16 组件通信
父=>子： props<br>子=>父： props event<br>不同组件（兄弟组件）：(1) 弟弟 => 父 => 哥哥 (2) EventEmitter (发布订阅机制)</li></ol></li><li><p>2020-10-15</p><ol><li><a href=https://github.com/hackftz/analysis-avalon/blob/main/deferred.js>Deferred实现</a><br>这个独立实现deferred在使用上来说不够优雅，Promise/A和Promise/A+更好。</li><li><a href=https://www.cnblogs.com/xiahj/p/8036419.html>深入研究-webkit-overflow-scrolling:touch及ios滚动</a><br>解决问题：safari上，当超出高度，页面往下滑时，浏览器底部的工具栏会随着页面一起晃动（向下滚动时会拉起底部工具栏），造成了很不好的体验。<br>解决方案：对inner content的min-height或者:after伪元素设置height加1%或1px。从而主动触发scrollbar。</li><li><a href=https://www.cnblogs.com/rubylouvre/p/3348250.html>ScrollFix.js：一个 iOS5 溢出滚动的（有限）修复方案</a><br>ScrollFix 的原理是这样的，在触摸开始时，如果发现滚动区域已经处于极限状态时，就手工设置 scrollTop 的值，将滚动内容向边缘方向偏移 1px（这实际上改变了滚动区域的极限状态），从而诱使浏览器对滚动区块使用橡皮筋效果，而不会把触摸事件向上传播到 DOM 树（引起整页滚动）。</li><li><a href=https://www.cnblogs.com/rubylouvre/p/3183616.html>javascript 的位操作符转换推断</a><br>字符串转number类型<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;10&#34;</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>0</span>;
<span style=color:#a6e22e>alert</span>(<span style=color:#a6e22e>a</span>); <span style=color:#75715e>// 10
</span><span style=color:#75715e></span><span style=color:#a6e22e>alert</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>a</span>); <span style=color:#75715e>// number
</span></code></pre></div></li><li><a href=https://www.cnblogs.com/rubylouvre/archive/2013/03/26/2979965.html>近似方法的实现</a><br>没啥好玩的</li><li><a href=https://www.cnblogs.com/rubylouvre/archive/2013/01/23/2872618.html>getCurrentScript的改进</a><br><a href=https://blog.csdn.net/cuixiping/article/details/45917149>获取当前Javascript脚本文件的路径</a><br>解决问题：模块加载器、日志log使用。<br>(1) document.currentScript<br>(2) make error to get the stack info from instance of Error<br>(3) script.readyState === &lsquo;interactive&rsquo;</li></ol></li><li><p>2020-10-14</p><ol><li><a href=https://www.cnblogs.com/rubylouvre/p/3348252.html>类继承已经过时了</a>——《设计模式：可复用面向对象软件的基础》downloaded</li><li><a href=https://www.cnblogs.com/tonyTao/p/5452498.html>谈谈 jQuery 中的防冲突（noConflict）机制</a>——avalonjs源码分析ing</li><li><a href=http://www.bubuko.com/infodetail-3219154.html>通俗易懂了解Vue中nextTick的内部实现原理</a></li><li><a href=https://www.cnblogs.com/rubylouvre/p/3290833.html>前端异步解决方案——mmDeferred</a><br>avalonjs中avalon.nexttick处理（setImmediate、MutationObserver、postMessage）avalon中在event事件中使用了window.postMessage来监听。<br>vue中则是使用了MessageChannel(MessageChannel基本上是一个双向通信管道.可以把它想象成window.postMessage。window.onmessage的替代品 – 但是更简单,更易于配置.)</li><li><a href=https://www.cnblogs.com/mfyngu/p/11747533.html>js 宏任务和微任务</a>——这里只做了定义，也没说怎么实现这个区分。</li><li><a href=https://blog.csdn.net/chongzhun5695/article/details/100867915>【Vue原理】NextTick - 源码版 之 宏微任务的抉择</a>——withMacroTask的使用，通过事件注册节点来区分宏和微。</li></ol></li><li><p>2020-10-13<br>离10月14号还有45分钟的时候 我开始写下了这篇当日计划</p><p>今天熟悉了下ts的泛型、枚举、类型推断部分。</p><p>其他：</p><ol><li><a href=https://www.cnblogs.com/rubylouvre/p/3659955.html>ES6中新添加的Array.prototype.fill</a></li><li><a href=https://www.cnblogs.com/rubylouvre/p/3364356.html>为什么框架很容易就走上大而全的不归之路？</a></li><li><a href=https://www.cnblogs.com/rubylouvre/p/3307413.html>自定义元素 – 在 HTML 中定义新元素</a></li></ol><p>10月14号 0:39分 网抑云ending</p></li></ul><a href=/>>> Home</a></main></div><footer><script>(function(){function center_el(tagName){var tags=document.getElementsByTagName(tagName),i,tag;for(i=0;i<tags.length;i++){tag=tags[i];var parent=tag.parentElement;if(parent.childNodes.length===1){if(parent.nodeName==='A'){parent=parent.parentElement;if(parent.childNodes.length!=1)continue;}
if(parent.nodeName==='P')parent.style.textAlign='center';}}}
var tagNames=['img','embed','object'];for(var i=0;i<tagNames.length;i++){center_el(tagNames[i]);}})();</script><hr>公众号: KeepinJS | <a href=mailto:472849306@qq.com>Email</a></footer></body></html>