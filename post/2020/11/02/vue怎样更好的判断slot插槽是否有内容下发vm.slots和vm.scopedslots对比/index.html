<!doctype html><html lang=en-us><head><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=manifest href=/images/site.webmanifest><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A simple, minimal blog for those who love text."><title>vue怎样更好的判断slot插槽是否有内容下发？（vm.$slots和vm.scopedSlots对比） | hackftz</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://hackftz.github.io/css/theme-override.css><header><nav><ul><li class=pull-left><a href=https://hackftz.github.io/>~/hackftz</a></li><li class=pull-left><a href=/categories/>~/categories</a></li><li class=pull-left><a href=/tags/>~/tags</a></li><li class=pull-right><a href=https://github.com/hackftz>~/github</a></li></ul></nav></header></head><body><br><div class=article-meta><h1><span class=title>vue怎样更好的判断slot插槽是否有内容下发？（vm.$slots和vm.scopedSlots对比）</span></h1><h2 class=author>hackftz</h2><h2 class=date>2020/11/02</h2><p class=terms>Categories: <a href=/categories/vue>vue</a>
Tags: <a href=/tags/2020-11>2020-11</a></p></div><div class=content-wrapper><main><h4 id=一前言>一、前言</h4><p>先贴一下源码 怎么处理scopedSlots的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>currentParent</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>forbidden</span>) {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>elseif</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>element</span>.<span style=color:#66d9ef>else</span>) {
      <span style=color:#a6e22e>processIfConditions</span>(<span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>currentParent</span>)
    } <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>slotScope</span>) {
        <span style=color:#75715e>// scoped slot
</span><span style=color:#75715e></span>        <span style=color:#75715e>// keep it in the children list so that v-else(-if) conditions can
</span><span style=color:#75715e></span>        <span style=color:#75715e>// find it as the prev node.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>slotTarget</span> <span style=color:#f92672>||</span> <span style=color:#e6db74>&#39;&#34;default&#34;&#39;</span>
        ;(<span style=color:#a6e22e>currentParent</span>.<span style=color:#a6e22e>scopedSlots</span> <span style=color:#f92672>||</span> (<span style=color:#a6e22e>currentParent</span>.<span style=color:#a6e22e>scopedSlots</span> <span style=color:#f92672>=</span> {}))[<span style=color:#a6e22e>name</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>element</span>
      }
      <span style=color:#a6e22e>currentParent</span>.<span style=color:#a6e22e>children</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>element</span>)
      <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>currentParent</span>
    }
  }
</code></pre></div><h4 id=二分析>二、分析</h4><p>在把template内容转为ast的过程当中，借用了数据算法中的堆栈技巧，将一个个vue dom解析为ast对象，从父到子插入到栈中，再重新构造一个ast树，在这个过程中，就对scopeSlot做了值的引用绑定。</p><h4 id=三解决问题>三、解决问题</h4><p>我们在项目中，做了封装search form和table list两个组件的封装，也就是search table这样一个集成了2个组件的通用组件，在这里使用了scope-slot插槽，某些页面是不需要更小的插槽组件传到子组件的，所以需要判断slot插槽下是否真实有内容存在。<br>开始使用了vm.$slots去解决，但是$slots只支持有具名插槽，但是对于将子组件属性在父级的插槽内容中暴露来使用的这种情况下，是无法作为判断依据的，所以不能使用这种判断方式，网上很多相关的解释也是有问题的。<br>所以在这里使用this.$scopedSlots来判断是最好的，根据源码，因为这个值是解析template时候就已经给它定义好了，如果声明了插槽但是没有给予实际内容，则为undefined。</p><h4 id=四附言>四、附言</h4><p><strong>vm.slots</strong>: 无响应性。用来访问被插槽分发的内容。具名插槽根据其下property来访问，默认default property为所有所有没有被包含在具名插槽中的节点，或v-slot:default的内容。</p><p><strong>vm.$scopedSlots</strong>: 用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。（对于插槽的复杂使用来说，给到的信息更加具体）</p><ol><li>vue 2.1.0 新增了 vm.$scopedSlots。</li><li>作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 undefined。</li><li>所有的slots现在都会暴露在scopedSlots中。如果你在使用渲染函数，不论当前插槽是否带有作用域，<strong>我们都推荐始终通过$scopedSlots访问它们。</strong></li></ol><a href=/>>> Home</a></main></div><footer><script>(function(){function center_el(tagName){var tags=document.getElementsByTagName(tagName),i,tag;for(i=0;i<tags.length;i++){tag=tags[i];var parent=tag.parentElement;if(parent.childNodes.length===1){if(parent.nodeName==='A'){parent=parent.parentElement;if(parent.childNodes.length!=1)continue;}
if(parent.nodeName==='P')parent.style.textAlign='center';}}}
var tagNames=['img','embed','object'];for(var i=0;i<tagNames.length;i++){center_el(tagNames[i]);}})();</script><hr>公众号: KeepinJS | <a href=mailto:472849306@qq.com>Email</a></footer></body></html>