<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Plan on hackftz</title><link>https://hackftz.github.io/categories/plan/</link><description>Recent content in Plan on hackftz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 12 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hackftz.github.io/categories/plan/index.xml" rel="self" type="application/rss+xml"/><item><title>Plan 2020,Oct</title><link>https://hackftz.github.io/post/2020/10/12/hacker-with-horn/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/12/hacker-with-horn/</guid><description>深入理解ts语法、用法、源码分析（暂时不用） 深入理解react 近版本迭代区别以及为何、语法、用法、源码分析 每天阅读至少三篇技术博客 阅读完在这里进行打卡record 打卡 2020-10-26
useMemo和useCallback的使用
useMemo：
官方解释：把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
个人定义：useMemo是为了减少不必要的重复计算。如果依赖无变化，会使用缓存的值；依赖变化的话，计算执行，并替换缓存值。
useCallback：
官方定义：把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。
个人定义：当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。也就是说父组件传递一个函数给子组件的时候，由于父组件的更新会导致该函数重新生成从而传递给子组件的函数引用发生了变化，这就会导致子组件也会更新，而很多时候子组件的更新是没必要的，所以我们可以通过useCallback来缓存该函数，然后传递给子组件。 上传文件multipart form-data boundary 说明 formdata实现原理（后续梳理，已发博客） 2020-10-25
useState用法指南
hooks中useState返回setXXX的用法，一种参数是直接赋值，一种是参数是匿名函数，两种之间的区别是：同步过程下没有区别，异步情况下，由于匿名函数中可以获取到prevXXX，所以可以获取到上一次状态，因此会在倒计时完成时触发一次次更新。
异步条件下，与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。 2020-10-24
useState用法指南
hooks中useState返回setXXX的用法，一种参数是直接赋值，一种是参数是匿名函数，两种之间的区别是：同步过程下没有区别，异步情况下，由于匿名函数中可以获取到prevXXX，所以可以获取到上一次状态，因此会在倒计时完成时触发一次次更新。 formdata实现原理（前言） 2020-10-21
React 16 要更改组件的生命周期
废弃了 componentWillMount，新增了 getDerivedStateFromProps。
消失的 componentWillMount 与新增的 getSnapshotBeforeUpdate。 React 16 组件通信 父=&amp;gt;子： props</description></item></channel></rss>