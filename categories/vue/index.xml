<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vue on hackftz</title><link>https://hackftz.github.io/categories/vue/</link><description>Recent content in Vue on hackftz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 28 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hackftz.github.io/categories/vue/index.xml" rel="self" type="application/rss+xml"/><item><title>深入理解TypeScript——文档篇之Symbols</title><link>https://hackftz.github.io/post/2020/10/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8Bsymbols/</link><pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8Bsymbols/</guid><description>一、介绍 Symbol是一种新的原生类型。
symbol类型的值是通过Symbol构造函数创建的。
let sym1 = Symbol(); let sym2 = Symbol(&amp;#34;key&amp;#34;); // 可选的字符串key 二、特性 不可改变且唯一 let sym2 = Symbol(&amp;#34;key&amp;#34;); let sym3 = Symbol(&amp;#34;key&amp;#34;); sym2 === sym3; // false, symbols是唯一的 symbols可以像字符串一样用做对象属性的键 let sym = Symbol(); let obj = { [sym]: &amp;#34;value&amp;#34; }; console.log(obj[sym]); // &amp;#34;value&amp;#34; 成员函数 const getClassNameSymbol = Symbol(); class C { [getClassNameSymbol](){ return &amp;#34;C&amp;#34;; } } let c = new C(); let className = c[getClassNameSymbol](); // &amp;#34;C&amp;#34; 三、内置symbols 内置symbols用来表示语言内部的行为。</description></item><item><title>深入理解TypeScript——文档篇之高级类型</title><link>https://hackftz.github.io/post/2020/10/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</link><pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</guid><description>一、交叉类型 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。
二、联合类型 联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 number | string | boolean表示一个值可以是 number， string，或 boolean。
/** * Takes a string and adds &amp;#34;padding&amp;#34; to the left. * If &amp;#39;padding&amp;#39; is a string, then &amp;#39;padding&amp;#39; is appended to the left side. * If &amp;#39;padding&amp;#39; is a number, then that number of spaces is added to the left side. */ function padLeft(value: string, padding: string | number) { // ... } let indentedString = padLeft(&amp;#34;Hello world&amp;#34;, true); 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</description></item><item><title>如何用vue实现一个矩形标记功能（rectangle marker）</title><link>https://hackftz.github.io/post/2020/10/27/%E5%A6%82%E4%BD%95%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%A0%87%E8%AE%B0%E5%8A%9F%E8%83%BDrectangle-marker/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/27/%E5%A6%82%E4%BD%95%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%A0%87%E8%AE%B0%E5%8A%9F%E8%83%BDrectangle-marker/</guid><description>代码地址：vue-rectangle-marker
一、前言 一些cms系统经常会用到区域标记功能，所以写了个用vue实现的矩形标记区域，包含拖拽、放大缩小、重置功能。
二、实现结果 初始 标记
三、代码实现 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;rectangle-marker&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;mark-wrap&amp;#34;&amp;gt; &amp;lt;img ref=&amp;#34;backImg&amp;#34; :src=&amp;#34;imgUrl&amp;#34; class=&amp;#34;img-responsive&amp;#34; alt=&amp;#34;响应式图像&amp;#34; @load=&amp;#34;onload&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;draw-rect&amp;#34; :class=&amp;#34;{ &amp;#39;no-event&amp;#39;: disabled }&amp;#34; @mousemove=&amp;#34;mouseMove&amp;#34; @mousedown=&amp;#34;mouseDown&amp;#34; @mouseup=&amp;#34;mouseUp&amp;#34;&amp;gt; &amp;lt;div ref=&amp;#34;box&amp;#34; v-if=&amp;#34;boxVisible&amp;#34; :id=&amp;#34;boxId&amp;#34; class=&amp;#34;box&amp;#34; :style=&amp;#34;{ width: boxW + &amp;#39;px&amp;#39;, height: boxH + &amp;#39;px&amp;#39;, left: boxL + &amp;#39;px&amp;#39;, top: boxT + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;upleftbtn&amp;#34; class=&amp;#34;upleftbtn&amp;#34; @mousedown=&amp;#34;onUpleftbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;uprightbtn&amp;#34; class=&amp;#34;uprightbtn&amp;#34; @mousedown=&amp;#34;onUpRightbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;downleftbtn&amp;#34; class=&amp;#34;downleftbtn&amp;#34; @mousedown=&amp;#34;onDownleftbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;downrightbtn&amp;#34; class=&amp;#34;downrightbtn&amp;#34; @mousedown=&amp;#34;onDownRightbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;transition name=&amp;#34;fade&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;showBtns &amp;amp;&amp;amp; !</description></item></channel></rss>