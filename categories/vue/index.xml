<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vue on hackftz</title><link>https://hackftz.github.io/categories/vue/</link><description>Recent content in Vue on hackftz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 10 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hackftz.github.io/categories/vue/index.xml" rel="self" type="application/rss+xml"/><item><title>vue为什么一定要在数组对象上绑定唯一key值？</title><link>https://hackftz.github.io/post/2020/11/10/vue%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%BB%91%E5%AE%9A%E5%94%AF%E4%B8%80key%E5%80%BC/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/11/10/vue%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%BB%91%E5%AE%9A%E5%94%AF%E4%B8%80key%E5%80%BC/</guid><description>一、前言 我们在使用vue开发时，经常会用到table、select options等组件，vue插件经常会提示我们在使用v-for遍历数组对象的时候要给template dom绑定key值。大多数人知道这个会提升性能，到底是什么性能呢？请往下看
二、官方解释 vue官方文档对key值的描述是这样的：
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=&amp;quot;$index&amp;rdquo;。
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key attribute：
&amp;lt;div v-for=&amp;#34;item in items&amp;#34; v-bind:key=&amp;#34;item.id&amp;#34;&amp;gt; // id不可重复且唯一 &amp;lt;!-- 内容 --&amp;gt; &amp;lt;/div&amp;gt; 三、key作用 key值可赋值为：number | string | boolean (2.4.2 新增) | symbol (2.5.12 新增)
dom diff为vue2.0新增的 性能优化点。
key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</description></item><item><title>vue怎样更好的判断slot插槽是否有内容下发？（vm.$slots和vm.scopedSlots对比）</title><link>https://hackftz.github.io/post/2020/11/02/vue%E6%80%8E%E6%A0%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%A4%E6%96%ADslot%E6%8F%92%E6%A7%BD%E6%98%AF%E5%90%A6%E6%9C%89%E5%86%85%E5%AE%B9%E4%B8%8B%E5%8F%91vm.slots%E5%92%8Cvm.scopedslots%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 02 Nov 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/11/02/vue%E6%80%8E%E6%A0%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%A4%E6%96%ADslot%E6%8F%92%E6%A7%BD%E6%98%AF%E5%90%A6%E6%9C%89%E5%86%85%E5%AE%B9%E4%B8%8B%E5%8F%91vm.slots%E5%92%8Cvm.scopedslots%E5%AF%B9%E6%AF%94/</guid><description>一、前言 先贴一下源码 怎么处理scopedSlots的
if (currentParent &amp;amp;&amp;amp; !element.forbidden) { if (element.elseif || element.else) { processIfConditions(element, currentParent) } else { if (element.slotScope) { // scoped slot // keep it in the children list so that v-else(-if) conditions can // find it as the prev node. const name = element.slotTarget || &amp;#39;&amp;#34;default&amp;#34;&amp;#39; ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element } currentParent.children.push(element) element.parent = currentParent } } 二、分析 在把template内容转为ast的过程当中，借用了数据算法中的堆栈技巧，将一个个vue dom解析为ast对象，从父到子插入到栈中，再重新构造一个ast树，在这个过程中，就对scopeSlot做了值的引用绑定。
三、解决问题 我们在项目中，做了封装search form和table list两个组件的封装，也就是search table这样一个集成了2个组件的通用组件，在这里使用了scope-slot插槽，某些页面是不需要更小的插槽组件传到子组件的，所以需要判断slot插槽下是否真实有内容存在。</description></item><item><title>如何用vue实现一个矩形标记功能（rectangle marker）</title><link>https://hackftz.github.io/post/2020/10/27/%E5%A6%82%E4%BD%95%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%A0%87%E8%AE%B0%E5%8A%9F%E8%83%BDrectangle-marker/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/27/%E5%A6%82%E4%BD%95%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%A0%87%E8%AE%B0%E5%8A%9F%E8%83%BDrectangle-marker/</guid><description>代码地址：vue-rectangle-marker
一、前言 一些cms系统经常会用到区域标记功能，所以写了个用vue实现的矩形标记区域，包含拖拽、放大缩小、重置功能。
二、实现结果 初始 标记
三、代码实现 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;rectangle-marker&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;mark-wrap&amp;#34;&amp;gt; &amp;lt;img ref=&amp;#34;backImg&amp;#34; :src=&amp;#34;imgUrl&amp;#34; class=&amp;#34;img-responsive&amp;#34; alt=&amp;#34;响应式图像&amp;#34; @load=&amp;#34;onload&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;draw-rect&amp;#34; :class=&amp;#34;{ &amp;#39;no-event&amp;#39;: disabled }&amp;#34; @mousemove=&amp;#34;mouseMove&amp;#34; @mousedown=&amp;#34;mouseDown&amp;#34; @mouseup=&amp;#34;mouseUp&amp;#34;&amp;gt; &amp;lt;div ref=&amp;#34;box&amp;#34; v-if=&amp;#34;boxVisible&amp;#34; :id=&amp;#34;boxId&amp;#34; class=&amp;#34;box&amp;#34; :style=&amp;#34;{ width: boxW + &amp;#39;px&amp;#39;, height: boxH + &amp;#39;px&amp;#39;, left: boxL + &amp;#39;px&amp;#39;, top: boxT + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;upleftbtn&amp;#34; class=&amp;#34;upleftbtn&amp;#34; @mousedown=&amp;#34;onUpleftbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;uprightbtn&amp;#34; class=&amp;#34;uprightbtn&amp;#34; @mousedown=&amp;#34;onUpRightbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;downleftbtn&amp;#34; class=&amp;#34;downleftbtn&amp;#34; @mousedown=&amp;#34;onDownleftbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;downrightbtn&amp;#34; class=&amp;#34;downrightbtn&amp;#34; @mousedown=&amp;#34;onDownRightbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;transition name=&amp;#34;fade&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;showBtns &amp;amp;&amp;amp; !</description></item></channel></rss>