<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020-11 on hackftz</title><link>https://hackftz.github.io/tags/2020-11/</link><description>Recent content in 2020-11 on hackftz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 10 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hackftz.github.io/tags/2020-11/index.xml" rel="self" type="application/rss+xml"/><item><title>vue为什么一定要在数组对象上绑定唯一key值？</title><link>https://hackftz.github.io/post/2020/11/10/vue%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%BB%91%E5%AE%9A%E5%94%AF%E4%B8%80key%E5%80%BC/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/11/10/vue%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%BB%91%E5%AE%9A%E5%94%AF%E4%B8%80key%E5%80%BC/</guid><description>一、前言 我们在使用vue开发时，经常会用到table、select options等组件，vue插件经常会提示我们在使用v-for遍历数组对象的时候要给template dom绑定key值。大多数人知道这个会提升性能，到底是什么性能呢？请往下看
二、官方解释 vue官方文档对key值的描述是这样的：
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=&amp;quot;$index&amp;rdquo;。
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key attribute：
&amp;lt;div v-for=&amp;#34;item in items&amp;#34; v-bind:key=&amp;#34;item.id&amp;#34;&amp;gt; // id不可重复且唯一 &amp;lt;!-- 内容 --&amp;gt; &amp;lt;/div&amp;gt; 三、key作用 key值可赋值为：number | string | boolean (2.4.2 新增) | symbol (2.5.12 新增)
dom diff为vue2.0新增的 性能优化点。
key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</description></item><item><title>使用gulp4自动生成一个reset.min.css</title><link>https://hackftz.github.io/post/2020/11/10/%E4%BD%BF%E7%94%A8gulp4%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAreset.min.css/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/11/10/%E4%BD%BF%E7%94%A8gulp4%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAreset.min.css/</guid><description>一、前言 团队需要开发一个前端开发脚手架，这里我要写一个reset.css文件，方便开发中使用。
因为不想只写一个临时文件，所以做成了一个工具。
好处就是，这样生成的文件可以在大多数项目中通用，可以大大减少css的代码量，提升项目性能。
项目地址：common-css-bag
二、项目目录 ├─ .gitignore ├─ config │ ├─ build.js │ ├─ clean.js │ ├─ concat.js │ └─ watch.js ├─ dist │ ├─ base.min.css │ ├─ box.min.css │ ├─ flex.min.css │ ├─ font.min.css │ └─ reset.min.css ├─ gulpfile.js ├─ index.css ├─ index.html ├─ package-lock.json ├─ package.json ├─ readme.md ├─ styles │ ├─ base.css // 基础reset │ ├─ box.css // 容器 │ ├─ flex.css // flex │ └─ font.</description></item><item><title>jsx dom嵌套层级太深 compose 组合/简化方法</title><link>https://hackftz.github.io/post/2020/11/03/jsx-dom%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E5%A4%AA%E6%B7%B1-compose-%E7%BB%84%E5%90%88/%E7%AE%80%E5%8C%96%E6%96%B9%E6%B3%95/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/11/03/jsx-dom%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E5%A4%AA%E6%B7%B1-compose-%E7%BB%84%E5%90%88/%E7%AE%80%E5%8C%96%E6%96%B9%E6%B3%95/</guid><description>摘自我在 BAT 写 React 是如何进行性能优化的
一、前言 react开发中，组件嵌套太深，怎么组合多个jsx dom的方法
二、 // 嵌套层级太深 const StateProviders = ({ children }) =&amp;gt; ( &amp;lt;LogProvider&amp;gt; &amp;lt;UserProvider&amp;gt; &amp;lt;MenuProvider&amp;gt; &amp;lt;AppProvider&amp;gt; {children} &amp;lt;/AppProvider&amp;gt; &amp;lt;/MenuProvider&amp;gt; &amp;lt;/UserProvider&amp;gt; &amp;lt;/LogProvider&amp;gt; ) function App() { return ( &amp;lt;StateProviders&amp;gt; &amp;lt;Main /&amp;gt; &amp;lt;/StateProviders&amp;gt; ) } // 简化 function composeProviders(...providers) { return ({ children }) =&amp;gt; providers.reduce( (prev, Provider) =&amp;gt; &amp;lt;Provider&amp;gt;{prev}&amp;lt;/Provider&amp;gt;, children, ) } const StateProviders = composeProviders( LogProvider, UserProvider, MenuProvider, AppProvider, ) function App() { return ( &amp;lt;StateProvider&amp;gt; &amp;lt;Main /&amp;gt; &amp;lt;/StateProvider&amp;gt; ) }</description></item><item><title>vue怎样更好的判断slot插槽是否有内容下发？（vm.$slots和vm.scopedSlots对比）</title><link>https://hackftz.github.io/post/2020/11/02/vue%E6%80%8E%E6%A0%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%A4%E6%96%ADslot%E6%8F%92%E6%A7%BD%E6%98%AF%E5%90%A6%E6%9C%89%E5%86%85%E5%AE%B9%E4%B8%8B%E5%8F%91vm.slots%E5%92%8Cvm.scopedslots%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 02 Nov 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/11/02/vue%E6%80%8E%E6%A0%B7%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%A4%E6%96%ADslot%E6%8F%92%E6%A7%BD%E6%98%AF%E5%90%A6%E6%9C%89%E5%86%85%E5%AE%B9%E4%B8%8B%E5%8F%91vm.slots%E5%92%8Cvm.scopedslots%E5%AF%B9%E6%AF%94/</guid><description>一、前言 先贴一下源码 怎么处理scopedSlots的
if (currentParent &amp;amp;&amp;amp; !element.forbidden) { if (element.elseif || element.else) { processIfConditions(element, currentParent) } else { if (element.slotScope) { // scoped slot // keep it in the children list so that v-else(-if) conditions can // find it as the prev node. const name = element.slotTarget || &amp;#39;&amp;#34;default&amp;#34;&amp;#39; ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element } currentParent.children.push(element) element.parent = currentParent } } 二、分析 在把template内容转为ast的过程当中，借用了数据算法中的堆栈技巧，将一个个vue dom解析为ast对象，从父到子插入到栈中，再重新构造一个ast树，在这个过程中，就对scopeSlot做了值的引用绑定。
三、解决问题 我们在项目中，做了封装search form和table list两个组件的封装，也就是search table这样一个集成了2个组件的通用组件，在这里使用了scope-slot插槽，某些页面是不需要更小的插槽组件传到子组件的，所以需要判断slot插槽下是否真实有内容存在。</description></item><item><title>Plan 2020,Nov</title><link>https://hackftz.github.io/post/2020/11/01/hacker-with-horn/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/11/01/hacker-with-horn/</guid><description>深入理解ts语法、用法、源码分析（暂时不用） 深入理解react 近版本迭代区别以及为何、语法、用法、源码分析 每天阅读至少三篇技术博客 阅读完在这里进行打卡record 打卡 2020-11-11
vue3.0中使用postcss-pxtorem 目前比较主流的移动端适配方案 用commitlint规范团队的git提交信息 使用起来较简单，会根据commitlint配置校验提交信息是否符合要求 前端提交信息规范——commitlint 2020-11-10
详解vue的diff算法 2020-11-09
Normalize.css 样式作用，及使用方法 common-css-bag——minify css工具 2020-11-05
nextTick为什么在Promise then之前执行 nextTick源码解析 2020-11-04
从编译过程，理解 Vue3 静态节点提升过程 2020-11-03
何时使用useLayoutEffect？ useEffect和useLayoutEffect 区别：
useLayoutEffect和平常写的ClassComponent的&amp;rsquo;componentDidMount'和&amp;rsquo;componentDidUpdate'同时执行。
useEffect会在本次更新完成后，也就是第1点的方法执行完成后，在开启一次任务调度，在下次任务调度中执行useEffect。 关于ref的一切 我在 BAT 写 React 是如何进行性能优化的 (1) 使用children 下发无状态组件 (2) context的 读写分离——读：有渲染，写：无渲染 (3) context 组织 集合 (4) jsx dom compose 方法（另附jsx dom嵌套层级太深 compose 组合/简化方法） 2020-11-01</description></item></channel></rss>