<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020-10 on hackftz</title><link>https://hackftz.github.io/tags/2020-10/</link><description>Recent content in 2020-10 on hackftz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 27 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hackftz.github.io/tags/2020-10/index.xml" rel="self" type="application/rss+xml"/><item><title>如何用vue实现一个矩形标记功能（rectangle marker）</title><link>https://hackftz.github.io/post/2020/10/27/%E5%A6%82%E4%BD%95%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%A0%87%E8%AE%B0%E5%8A%9F%E8%83%BDrectangle-marker/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/27/%E5%A6%82%E4%BD%95%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%A0%87%E8%AE%B0%E5%8A%9F%E8%83%BDrectangle-marker/</guid><description>代码地址：vue-rectangle-marker
一、前言 一些cms系统经常会用到区域标记功能，所以写了个用vue实现的矩形标记区域，包含拖拽、放大缩小、重置功能。
二、实现结果 初始 标记
三、代码实现 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;rectangle-marker&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;mark-wrap&amp;#34;&amp;gt; &amp;lt;img ref=&amp;#34;backImg&amp;#34; :src=&amp;#34;imgUrl&amp;#34; class=&amp;#34;img-responsive&amp;#34; alt=&amp;#34;响应式图像&amp;#34; @load=&amp;#34;onload&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;draw-rect&amp;#34; :class=&amp;#34;{ &amp;#39;no-event&amp;#39;: disabled }&amp;#34; @mousemove=&amp;#34;mouseMove&amp;#34; @mousedown=&amp;#34;mouseDown&amp;#34; @mouseup=&amp;#34;mouseUp&amp;#34;&amp;gt; &amp;lt;div ref=&amp;#34;box&amp;#34; v-if=&amp;#34;boxVisible&amp;#34; :id=&amp;#34;boxId&amp;#34; class=&amp;#34;box&amp;#34; :style=&amp;#34;{ width: boxW + &amp;#39;px&amp;#39;, height: boxH + &amp;#39;px&amp;#39;, left: boxL + &amp;#39;px&amp;#39;, top: boxT + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;upleftbtn&amp;#34; class=&amp;#34;upleftbtn&amp;#34; @mousedown=&amp;#34;onUpleftbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;uprightbtn&amp;#34; class=&amp;#34;uprightbtn&amp;#34; @mousedown=&amp;#34;onUpRightbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;downleftbtn&amp;#34; class=&amp;#34;downleftbtn&amp;#34; @mousedown=&amp;#34;onDownleftbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;downrightbtn&amp;#34; class=&amp;#34;downrightbtn&amp;#34; @mousedown=&amp;#34;onDownRightbtn&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;transition name=&amp;#34;fade&amp;#34;&amp;gt; &amp;lt;div v-if=&amp;#34;showBtns &amp;amp;&amp;amp; !</description></item><item><title>如何实现一个FormData</title><link>https://hackftz.github.io/post/2020/10/26/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAformdata/</link><pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/26/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAformdata/</guid><description>一、前言 最近项目中遇到一个问题，我们需要在cocos项目里去上传音频文件，而cocos原生环境和平时我们开发所在的浏览器环境和Node环境有很多差异，而cocos环境只提供了基础类，没有提供FormData这种封装类。
所以问题来了？如何实现一个FormData，以及怎么去使用它？
二、浏览器中的FormData 这里我列一个最简单的例子，我们来看看FormData到底是什么。 \
function App() { const [name, setName] = useState(&amp;#39;&amp;#39;) const [age, setAge] = useState(0) const [file, setFile] = useState&amp;lt;File | null&amp;gt;() const submit = () =&amp;gt; { console.log(name, age); console.log(file); var fd = new FormData() fd.append(&amp;#39;name&amp;#39;, name) fd.append(&amp;#39;age&amp;#39;, age.toString()) fd.append(&amp;#39;file&amp;#39;, file as Blob) $.ajax({ type: &amp;#34;POST&amp;#34;, url: &amp;#34;www.happy.com&amp;#34;, data: fd, processData: false,//重要 contentType: &amp;#39;multipart/form-data&amp;#39;,//重要 success: function (data: any) { } }) } return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; &amp;lt;form action=&amp;#34;form_action.</description></item><item><title>git clone很慢 怎么办？是不是用了 解析github.global.ssl.fastly.net ip？？</title><link>https://hackftz.github.io/post/2020/10/15/hacker-with-horn/</link><pubDate>Thu, 15 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/15/hacker-with-horn/</guid><description>网上很多人说的修改host方法，已经行不通了。。
199.232.69.194 github.global.ssl.fastly.net这个方法使用后速度会降低很多，实测从100多k降到10k，实在是有点坑！</description></item><item><title>深入理解TypeScript——文档篇之枚举</title><link>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%9E%9A%E4%B8%BE/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%9E%9A%E4%B8%BE/</guid><description>一、概念 使用枚举我们可以定义一些带名字的常量。 我理解的是使用枚举，可以解决我们在项目中定义常量不规范的问题。
数字枚举
// 使用初始化器 enum Direction { // 定义数字枚举 Up = 1, // 使用初始化器，初始值1 Down, // 2 Left, // 3 Right // 4 // ...定义依次递增 } // 不使用初始化器 enum Direction { Up, // 0 Down, // 1 Left, Right, } 通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型
enum Response { No = 0, Yes = 1, } function respond(recipient: string, message: Response): void { console.log(recipient + &amp;#39; &amp;#39; + message); } respond(&amp;#34;Princess Caroline&amp;#34;, Response.</description></item><item><title>深入理解TypeScript——文档篇之泛型</title><link>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%B3%9B%E5%9E%8B/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%B3%9B%E5%9E%8B/</guid><description>一、介绍 类型变量，它是一种特殊的变量，只用于表示类型而不是值。
function identity&amp;lt;T&amp;gt;(arg: T): T { // 声明带有泛型的函数 return arg; } 二、使用 传入所有的参数，包含类型参数：
let output = identity&amp;lt;string&amp;gt;(&amp;#34;myString&amp;#34;); // type of output will be &amp;#39;string&amp;#39; 类型推论
let output = identity(&amp;#34;myString&amp;#34;); // type of output will be &amp;#39;string&amp;#39; 编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。
三、类型 类型参数在最前面。
function identity&amp;lt;T&amp;gt;(arg: T): T { return arg; } let myIdentity: &amp;lt;T&amp;gt;(arg: T) =&amp;gt; T = identity; 可以使用不同的泛型参数名。
function identity&amp;lt;T&amp;gt;(arg: T): T { return arg; } let myIdentity: &amp;lt;U&amp;gt;(arg: U) =&amp;gt; U = identity; 使用带有调用签名的对象字面量来定义。</description></item><item><title>深入理解TypeScript——文档篇之类型推断</title><link>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</guid><description>一、基础 TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型
let x = 3; // let x: number 二、最佳通用类型 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。
// demo 1 let x = [0, 1, null, &amp;#39;haha&amp;#39;]; // let x: (string | number | null)[] // demo 2 class Rhino { constructor() { } } class Elephant { constructor() { } } class Snake { constructor() { } } let zoo = [new Rhino(), new Elephant(), new Snake()]; // let zoo: (Rhino | Elephant | Snake)[] 三、上下文类型 TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。</description></item><item><title>Plan 2020,Oct</title><link>https://hackftz.github.io/post/2020/10/12/hacker-with-horn/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/12/hacker-with-horn/</guid><description>深入理解ts语法、用法、源码分析（暂时不用） 深入理解react 近版本迭代区别以及为何、语法、用法、源码分析 每天阅读至少三篇技术博客 阅读完在这里进行打卡record 打卡 2020-10-26
useMemo和useCallback的使用
useMemo：
官方解释：把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。
个人定义：useMemo是为了减少不必要的重复计算。如果依赖无变化，会使用缓存的值；依赖变化的话，计算执行，并替换缓存值。
useCallback：
官方定义：把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。
个人定义：当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。也就是说父组件传递一个函数给子组件的时候，由于父组件的更新会导致该函数重新生成从而传递给子组件的函数引用发生了变化，这就会导致子组件也会更新，而很多时候子组件的更新是没必要的，所以我们可以通过useCallback来缓存该函数，然后传递给子组件。 上传文件multipart form-data boundary 说明 formdata实现原理（后续梳理，已发博客） 2020-10-25
useState用法指南
hooks中useState返回setXXX的用法，一种参数是直接赋值，一种是参数是匿名函数，两种之间的区别是：同步过程下没有区别，异步情况下，由于匿名函数中可以获取到prevXXX，所以可以获取到上一次状态，因此会在倒计时完成时触发一次次更新。
异步条件下，与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。 2020-10-24
useState用法指南
hooks中useState返回setXXX的用法，一种参数是直接赋值，一种是参数是匿名函数，两种之间的区别是：同步过程下没有区别，异步情况下，由于匿名函数中可以获取到prevXXX，所以可以获取到上一次状态，因此会在倒计时完成时触发一次次更新。 formdata实现原理（前言） 2020-10-21
React 16 要更改组件的生命周期
废弃了 componentWillMount，新增了 getDerivedStateFromProps。
消失的 componentWillMount 与新增的 getSnapshotBeforeUpdate。 React 16 组件通信 父=&amp;gt;子： props</description></item><item><title>深入理解TypeScript——文档篇之函数</title><link>https://hackftz.github.io/post/2020/10/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/</guid><description>一、函数类型 定义函数类型
// 函数式声明 function add(x: number, y: number): number { return x + y; } // 由变量指向的匿名函数 let myAdd = function(x: number, y: number): number { return x + y; }; 完整函数类型
let myAdd: (x: number, y: number) =&amp;gt; number = function(x: number, y: number): number { return x + y; }; 通常需要将类型抽离成接口，形成规范。
推断类型
函数定义赋值语句一边有类型。
// myAdd has the full function type let myAdd = function(x: number, y: number): number { return x + y; }; // The parameters `x` and `y` have the type number let myAdd: (baseValue: number, increment: number) =&amp;gt; number = function(x, y) { return x + y; }; 二、可选参数、默认参数 ​ ts中传递给一个函数的参数个数必须与函数期望的参数个数一致。</description></item><item><title>深入理解TypeScript——文档篇之接口</title><link>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%8E%A5%E5%8F%A3/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%8E%A5%E5%8F%A3/</guid><description>接口是ts的核心之一，它的作用就是先约定好，再在定义的地方检查各种数据结构。
一、鸭子辩型法 鸭式辨型：像鸭子一样走路、游泳和嘎嘎叫的鸟就是鸭子。如下：
interface Duck { walkLikeDuck(): any swim(): any gaga(): any } class Animal { walkLikeDuck() { console.log(&amp;#39;look!, I walk like a duck.&amp;#39;) } swim() { console.log(&amp;#39;YES! I can swim very well.&amp;#39;) } gaga() { console.log(&amp;#39;gaga&amp;#39;) } } let duck: Duck = new Animal() console.log(duck); 二、初识 理解为将函数、变量定义等等中的数据检查，抽离出来，成为接口。
三、可选属性（“option bags”模式） 与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。
interface SquareConfig { color?: string; width?: number; } 四、只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:
interface Point { readonly x: number; readonly y: number; } TypeScript具有ReadonlyArray&amp;lt;T&amp;gt;类型，数组创建后再也不能被修改。</description></item><item><title>深入理解TypeScript——文档篇之类</title><link>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB/</guid><description>一、js和ts类的区别 js是基于类的面向对象方式，构建父子类的继承结构，写起来不简洁，也不形象。ts则是以简洁明了的方式实现类的定义、继承、扩展等等。
之前我也提过，js最终会登录浏览器平台，但是至少不是现在，所以在下一个js时代之前，我们需要定ts来规范当前的客户端代码。
二、用ts实现类 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &amp;#34;Hello, &amp;#34; + this.greeting; } } let greeter = new Greeter(&amp;#34;world&amp;#34;); 三、继承 使用extends 关键字来继承。
class Animal { // Animal是基类，也叫超类 move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { // Dog是派生自Animal的派生类，也叫子类 bark() { console.log(&amp;#39;Woof! Woof!&amp;#39;); } } const dog = new Dog(); dog.bark(); dog.move(10); 派生类的构造函数必须包含 &amp;ldquo;super&amp;rdquo; 调用。这是ts强制执行的一条重要规则。</description></item></channel></rss>