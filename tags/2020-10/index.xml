<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020-10 on hackftz</title><link>https://hackftz.github.io/tags/2020-10/</link><description>Recent content in 2020-10 on hackftz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 13 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hackftz.github.io/tags/2020-10/index.xml" rel="self" type="application/rss+xml"/><item><title>深入理解TypeScript——文档篇之枚举</title><link>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%9E%9A%E4%B8%BE/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%9E%9A%E4%B8%BE/</guid><description>一、概念 使用枚举我们可以定义一些带名字的常量。 我理解的是使用枚举，可以解决我们在项目中定义常量不规范的问题。
数字枚举
// 使用初始化器 enum Direction { // 定义数字枚举 Up = 1, // 使用初始化器，初始值1 Down, // 2 Left, // 3 Right // 4 // ...定义依次递增 } // 不使用初始化器 enum Direction { Up, // 0 Down, // 1 Left, Right, } 通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型
enum Response { No = 0, Yes = 1, } function respond(recipient: string, message: Response): void { console.log(recipient + &amp;#39; &amp;#39; + message); } respond(&amp;#34;Princess Caroline&amp;#34;, Response.</description></item><item><title>深入理解TypeScript——文档篇之泛型</title><link>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%B3%9B%E5%9E%8B/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%B3%9B%E5%9E%8B/</guid><description>一、介绍 类型变量，它是一种特殊的变量，只用于表示类型而不是值。
function identity&amp;lt;T&amp;gt;(arg: T): T { // 声明带有泛型的函数 return arg; } 二、使用 传入所有的参数，包含类型参数：
let output = identity&amp;lt;string&amp;gt;(&amp;#34;myString&amp;#34;); // type of output will be &amp;#39;string&amp;#39; 类型推论
let output = identity(&amp;#34;myString&amp;#34;); // type of output will be &amp;#39;string&amp;#39; 编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。
三、类型 类型参数在最前面。
function identity&amp;lt;T&amp;gt;(arg: T): T { return arg; } let myIdentity: &amp;lt;T&amp;gt;(arg: T) =&amp;gt; T = identity; 可以使用不同的泛型参数名。
function identity&amp;lt;T&amp;gt;(arg: T): T { return arg; } let myIdentity: &amp;lt;U&amp;gt;(arg: U) =&amp;gt; U = identity; 使用带有调用签名的对象字面量来定义。</description></item><item><title>深入理解TypeScript——文档篇之类型推断</title><link>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</guid><description>一、基础 TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型
let x = 3; // let x: number 二、最佳通用类型 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。
// demo 1 let x = [0, 1, null, &amp;#39;haha&amp;#39;]; // let x: (string | number | null)[] // demo 2 class Rhino { constructor() { } } class Elephant { constructor() { } } class Snake { constructor() { } } let zoo = [new Rhino(), new Elephant(), new Snake()]; // let zoo: (Rhino | Elephant | Snake)[] 三、上下文类型 TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。</description></item><item><title>深入理解TypeScript——文档篇之函数</title><link>https://hackftz.github.io/post/2020/10/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/</guid><description>一、函数类型 定义函数类型
// 函数式声明 function add(x: number, y: number): number { return x + y; } // 由变量指向的匿名函数 let myAdd = function(x: number, y: number): number { return x + y; }; 完整函数类型
let myAdd: (x: number, y: number) =&amp;gt; number = function(x: number, y: number): number { return x + y; }; 通常需要将类型抽离成接口，形成规范。
推断类型
函数定义赋值语句一边有类型。
// myAdd has the full function type let myAdd = function(x: number, y: number): number { return x + y; }; // The parameters `x` and `y` have the type number let myAdd: (baseValue: number, increment: number) =&amp;gt; number = function(x, y) { return x + y; }; 二、可选参数、默认参数 ​ ts中传递给一个函数的参数个数必须与函数期望的参数个数一致。</description></item><item><title>深入理解TypeScript——文档篇之接口</title><link>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%8E%A5%E5%8F%A3/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%8E%A5%E5%8F%A3/</guid><description>接口是ts的核心之一，它的作用就是先约定好，再在定义的地方检查各种数据结构。
一、鸭子辩型法 鸭式辨型：像鸭子一样走路、游泳和嘎嘎叫的鸟就是鸭子。如下：
interface Duck { walkLikeDuck(): any swim(): any gaga(): any } class Animal { walkLikeDuck() { console.log(&amp;#39;look!, I walk like a duck.&amp;#39;) } swim() { console.log(&amp;#39;YES! I can swim very well.&amp;#39;) } gaga() { console.log(&amp;#39;gaga&amp;#39;) } } let duck: Duck = new Animal() console.log(duck); 二、初识 理解为将函数、变量定义等等中的数据检查，抽离出来，成为接口。
三、可选属性（“option bags”模式） 与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。
interface SquareConfig { color?: string; width?: number; } 四、只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:
interface Point { readonly x: number; readonly y: number; } TypeScript具有ReadonlyArray&amp;lt;T&amp;gt;类型，数组创建后再也不能被修改。</description></item><item><title>深入理解TypeScript——文档篇之类</title><link>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB/</guid><description>一、js和ts类的区别 js是基于类的面向对象方式，构建父子类的继承结构，写起来不简洁，也不形象。ts则是以简洁明了的方式实现类的定义、继承、扩展等等。
之前我也提过，js最终会登录浏览器平台，但是至少不是现在，所以在下一个js时代之前，我们需要定ts来规范当前的客户端代码。
二、用ts实现类 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &amp;#34;Hello, &amp;#34; + this.greeting; } } let greeter = new Greeter(&amp;#34;world&amp;#34;); 三、继承 使用extends 关键字来继承。
class Animal { // Animal是基类，也叫超类 move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { // Dog是派生自Animal的派生类，也叫子类 bark() { console.log(&amp;#39;Woof! Woof!&amp;#39;); } } const dog = new Dog(); dog.bark(); dog.move(10); 派生类的构造函数必须包含 &amp;ldquo;super&amp;rdquo; 调用。这是ts强制执行的一条重要规则。</description></item><item><title>Plan 2020,Oct</title><link>https://hackftz.github.io/post/2012/04/23/hacker-with-horn/</link><pubDate>Mon, 23 Apr 2012 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2012/04/23/hacker-with-horn/</guid><description> 深入理解ts语法、用法、源码分析（暂时不用） 深入理解react 近版本迭代区别以及为何、语法、用法、源码分析 每天阅读至少三篇技术博客 阅读完在这里进行打卡record 打卡 2020-10-13
离10月14号还有45分钟的时候 我开始写下了这篇当日计划
今天熟悉了下ts的泛型、枚举、类型推断部分。
其他：
ES6中新添加的Array.prototype.fill 为什么框架很容易就走上大而全的不归之路？ 自定义元素 – 在 HTML 中定义新元素 10月14号 0:39分 网抑云ending
2020-10-14
类继承已经过时了——《设计模式：可复用面向对象软件的基础》downloaded 谈谈 jQuery 中的防冲突（noConflict）机制——avalonjs源码分析ing 通俗易懂了解Vue中nextTick的内部实现原理 前端异步解决方案——mmDeferred
avalonjs中avalon.nexttick处理（setImmediate、MutationObserver、postMessage）avalon中使用了postMessage
vue中则是使用了MessageChannel(MessageChannel基本上是一个双向通信管道.可以把它想象成window.postMessage / window.onmessage的替代品 – 但是更简单,更易于配置.) js 宏任务和微任务——这里只做了定义，也没说怎么实现这个区分 【Vue原理】NextTick - 源码版 之 宏微任务的抉择——withMacroTask的使用</description></item></channel></rss>