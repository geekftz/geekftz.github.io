<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020-10 on hackftz</title><link>https://hackftz.github.io/tags/2020-10/</link><description>Recent content in 2020-10 on hackftz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hackftz.github.io/tags/2020-10/index.xml" rel="self" type="application/rss+xml"/><item><title>深入理解TypeScript——文档篇之接口</title><link>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%8E%A5%E5%8F%A3/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E6%8E%A5%E5%8F%A3/</guid><description>接口是ts的核心之一，它的作用就是先约定好，再在定义的地方检查各种数据结构。
一、鸭子辩型法 鸭式辨型：像鸭子一样走路、游泳和嘎嘎叫的鸟就是鸭子。如下：
interface Duck { walkLikeDuck(): any swim(): any gaga(): any } class Animal { walkLikeDuck() { console.log(&amp;#39;look!, I walk like a duck.&amp;#39;) } swim() { console.log(&amp;#39;YES! I can swim very well.&amp;#39;) } gaga() { console.log(&amp;#39;gaga&amp;#39;) } } let duck: Duck = new Animal() console.log(duck); 二、初识 理解为将函数、变量定义等等中的数据检查，抽离出来，成为接口。
三、可选属性（“option bags”模式） 与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。
interface SquareConfig { color?: string; width?: number; } 四、只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:
interface Point { readonly x: number; readonly y: number; } TypeScript具有ReadonlyArray&amp;lt;T&amp;gt;类型，数组创建后再也不能被修改。</description></item><item><title>深入理解TypeScript——文档篇之类</title><link>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2020/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript%E6%96%87%E6%A1%A3%E7%AF%87%E4%B9%8B%E7%B1%BB/</guid><description>一、js和ts类的区别 js是基于类的面向对象方式，构建父子类的继承结构，写起来不简洁，也不形象。ts则是以简洁明了的方式实现类的定义、继承、扩展等等。
之前我也提过，js最终会登录浏览器平台，但是至少不是现在，所以在下一个js时代之前，我们需要定ts来规范当前的客户端代码。
二、用ts实现类 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &amp;#34;Hello, &amp;#34; + this.greeting; } } let greeter = new Greeter(&amp;#34;world&amp;#34;); 三、继承 使用extends 关键字来继承。
class Animal { // Animal是基类，也叫超类 move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { // Dog是派生自Animal的派生类，也叫子类 bark() { console.log(&amp;#39;Woof! Woof!&amp;#39;); } } const dog = new Dog(); dog.bark(); dog.move(10); 派生类的构造函数必须包含 &amp;ldquo;super&amp;rdquo; 调用。这是ts强制执行的一条重要规则。</description></item><item><title>Plan 2020,Oct</title><link>https://hackftz.github.io/post/2012/04/23/hacker-with-horn/</link><pubDate>Mon, 23 Apr 2012 00:00:00 +0000</pubDate><guid>https://hackftz.github.io/post/2012/04/23/hacker-with-horn/</guid><description/></item></channel></rss>